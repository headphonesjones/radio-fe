// Generated by CoffeeScript 1.6.3
var compile, debug, each, fs, getDependencies, lint, logger, pipeline, throwError, waterfall,
  _this = this;

each = require('async-each');

waterfall = require('async-waterfall');

debug = require('debug')('brunch:pipeline');

fs = require('fs');

logger = require('loggy');

throwError = function(type, stringOrError) {
  var error, string;
  string = stringOrError instanceof Error ? stringOrError.toString().replace(/^([^:]+:\s+)/, '') : stringOrError;
  error = new Error(string);
  error.brunchType = type;
  return error;
};

lint = function(data, path, linters, callback) {
  if (linters.length === 0) {
    return callback(null);
  } else {
    return each(linters, function(linter, callback) {
      return linter.lint(data, path, callback);
    }, callback);
  }
};

getDependencies = function(data, path, compiler, callback) {
  if (compiler.getDependencies) {
    return compiler.getDependencies(data, path, callback);
  } else {
    return callback(null, []);
  }
};

compile = function(initialData, path, compilers, callback) {
  var chained, first,
    _this = this;
  chained = compilers.map(function(compiler) {
    var compilerName;
    compilerName = compiler.constructor.name;
    return function(params, next) {
      var compiled, compilerArgs, compilerData, dependencies, source, sourceMap;
      if (!params) {
        return next();
      }
      dependencies = params.dependencies, compiled = params.compiled, source = params.source, sourceMap = params.sourceMap, path = params.path;
      debug("Compiling '" + path + "' with '" + compilerName + "'");
      compilerData = compiled || source;
      compilerArgs = compiler.compile.length === 2 ? [
        {
          data: compilerData,
          path: path,
          map: sourceMap
        }
      ] : [compilerData, path];
      compilerArgs.push(function(error, result) {
        var _this = this;
        if (error != null) {
          return callback(throwError('Compiling', error));
        }
        if (result == null) {
          return next();
        }
        if (toString.call(result) === '[object Object]') {
          if (result.map != null) {
            sourceMap = result.map;
          }
          compiled = result.data;
        } else {
          compiled = result;
        }
        if (compiled == null) {
          throw new Error("Brunch SourceFile: file " + path + " data is invalid");
        }
        debug("getDependencies '" + path + "' with '" + compilerName + "'");
        return getDependencies(source, path, compiler, function(error, dependencies) {
          if (error != null) {
            return callback(throwError('Dependency parsing', error));
          }
          return next(null, {
            dependencies: dependencies,
            compiled: compiled,
            source: source,
            sourceMap: sourceMap,
            path: path
          });
        });
      });
      return compiler.compile.apply(compiler, compilerArgs);
    };
  });
  first = function(next) {
    return next(null, {
      source: initialData,
      path: path
    });
  };
  return waterfall([first].concat(chained), callback);
};

pipeline = function(path, linters, compilers, callback) {
  debug("Reading '" + path + "'");
  return fs.readFile(path, 'utf-8', function(error, source) {
    if (error != null) {
      return callback(throwError('Reading', error));
    }
    debug("Linting '" + path + "'");
    return lint(source, path, linters, function(error) {
      if (error != null ? error.match(/^warn\:\s/i) : void 0) {
        return logger.warn("Linting of " + path + ": " + error);
      } else {
        if (error != null) {
          return callback(throwError('Linting', error));
        }
        return compile(source, path, compilers, callback);
      }
    });
  });
};

exports.pipeline = pipeline;
